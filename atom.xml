<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zivkidd.github.io</id>
    <title>Noodlesoup</title>
    <updated>2022-04-12T11:24:20.517Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zivkidd.github.io"/>
    <link rel="self" href="https://zivkidd.github.io/atom.xml"/>
    <subtitle>emm noodlesoup</subtitle>
    <logo>https://zivkidd.github.io/images/avatar.png</logo>
    <icon>https://zivkidd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Noodlesoup</rights>
    <entry>
        <title type="html"><![CDATA[俄乌战争定性及台海风云——卢麒元]]></title>
        <id>https://zivkidd.github.io/post/e-wu-zhan-zheng-ding-xing-ji-tai-hai-feng-yun-lu-qi-yuan/</id>
        <link href="https://zivkidd.github.io/post/e-wu-zhan-zheng-ding-xing-ji-tai-hai-feng-yun-lu-qi-yuan/">
        </link>
        <updated>2022-04-12T11:20:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>大家好,今天是2022年4月9号，壬寅年三月初九。今天我们聊天，我们要聊一下子俄乌战争的定性及卢布起义的启示及影响。今天的聊天重要，今天的聊天大家可以把它公开，并且有些内容大家可以截取或者是把它写成自己的文字。我们今天不聊疫情了，下个星期再说吧。因为这一件事情重要，因为它跟市场也有密切联系，另外好多事情到了必须说一说的时候了。好，我们三点钟准时开始。</p>
</li>
<li>
<p>大家好，今天是2022年的4月9号，壬寅年三月初九，这个时间节点非常重要。今天是聊天，其实今天这个聊天，亦非我自己想做这样一个安排，是朋友们要求我谈一下子。我其实是写了文章的，但是显然这样的文章可能现在不合时宜，不能发表。那么我们就今天当成聊天给大家吧，送给朋友们。今天我们聊俄乌战争的定性及卢布起义的启示及影响。确实是非常重要。</p>
</li>
<li>
<p>审视一场战争，首先必须回到哲学的高度。我们现在对俄乌战争的看法，有西方的看法，他们都认为这是一场侵略战争。也有俄方的看法，俄方整体上对战争的描述虽然不是侵略战争，他也是认为是一场自卫的军事行动。记住是自卫的军事行动。我方对俄乌战争的性质没有给予明确的定义，但我们认为这毕竟是对其他主权国家的一种军事侵略行为。那么我们该怎样定义俄乌战争的性质呢？</p>
</li>
<li>
<p>定义俄乌战争的性质多么的重要，是因为早晚中国也需要对中国周边地区用兵，比如对日、对韩、对新、对台。如用兵，我们将如何站在哲学的高度解释呢？这是一场什么性质的战争？如果不在这个层面有清晰的解释，那么在意识形态层面、在舆论战层面、在信息战层面，其实我们就失去了高度。所以对俄乌战争的性质的定性一直是一个非常严肃的、非常重要的哲学问题。然而我们讨论这场战争往往陷入细节而忽略了哲学高度。</p>
</li>
<li>
<p>在讨论性质之前，我想重新重复一下子我们讲《资本论》的时候的对殖民史的定义。殖民史我们划为三段。一段是叫做古典殖民历史，它主要是五百年前哥伦布发现了新大陆之后，老牌的殖民主义国家从荷兰、西班牙乃至于英国开始对其他国家和地区进行殖民的行为。古典殖民的行为特征是种族灭绝，所以在北美，印第安人，在其他地方都发生了大规模种族灭绝的行为。因为它……</p>
</li>
<li>
<p>古典殖民的特征，它是要土地、要生产资料，而不要人。现代殖民我们是依据马克思《资本论》第二十五章《现代殖民原理》上面基本的定义，那就是它不再进行种族灭绝，也有种族屠杀，但不是以种族灭绝为目的，而是消灭资产持有者，取而代之，同时保留生产资料和生产力。殖民，现代殖民的特征。我为什么要谈殖民历史？请注意，请注意，俄罗斯和整个斯拉夫民族在古典殖民历史时期，他们是殖民者，乃至于到了社会主义苏联仍具有殖民者特征。</p>
</li>
<li>
<p>我国的伟大领袖毛泽东，将之定义为大国沙文主义，仍是殖民主义的一种特征。然而，到了第三阶段，性质发生了变化，我说的是后殖民主义。进入后殖民主义时代，它的标准时间应是1945年之后。1945年进入后殖民主义时代资本的殖民特征就不主要是通过军事占领、通过对生产资料持有者的消灭来占有生产资料和劳动力，而是通过资本殖民的方式进行新型的、被标贴为民主制度的那种新形式的殖民。</p>
</li>
<li>
<p>在后殖民主义阶段可以做一个分期，其中上个世纪九十年代初，随着苏联的解体，它进入到后殖民主义高峰期或者是后殖民主义的后半段。意味着什么呢？以斯拉夫民族为代表的原殖民者成为后殖民主义的殖民对象。我进行的是一种哲学的论述，有些地方可能很多朋友未必同意，未必接受。不要紧，不要紧，我们要学会站在哲学的高度和历史的这个长度，来对现实问题进行思考和总结。这一点非常重要，其中……</p>
</li>
<li>
<p>其中对斯拉夫民族的个别地区，后殖民主义形成了完整的殖民，例如乌克兰，乌克兰。也意味着斯拉夫民族的一部分成为了后殖民主义的殖民地。虽然他不再像以前印度或者是美洲那样的那种形态的殖民地，是资本殖民的殖民地，他无论是从意识形态还是从管理者，他都是代理人直接治理，就是美国人，拿有美国身份证的人或者是代理者殖民，他的特征是明确的。如果你能理解我刚才对殖民理论的描述，</p>
</li>
<li>
<p>那么我们可以对俄乌战争做一个历史性的概述。其实这个历史的变迁是有意思的，从殖民者到被殖民者，到反对后殖民主义者，这是一个历史的一种很神奇的变化。所以，今天我们来概述这一件事情，要从这个地方入手。好吧，我们现在就给出定性：俄乌战争是由俄罗斯领导的斯拉夫民族反抗美英帝国主义和殖民主义的解放战争。重复，俄乌战争是俄罗斯领导……</p>
</li>
</ol>
<p>11.再重复，俄乌战争是俄罗斯领导的斯拉夫民族为反抗美英帝国主义和殖民主义的解放战争，或者把它说成是民族解放战争。将来我们也会用同样的定义来解释我国周边可能发生的战事。记着，对一个战争的定性是至关重要的，它不一定被广泛地接受，但是我们对一件事情要有我们独立的思考和我们的看法，否则我们对所有的事情无法做出合理的、合理性的解读，我们将失去话语权。</p>
<p>12.事实上，殖民主义五百多年的发展历史里边，已经走入最后的阶段，就是后殖民主义的后半段。因为后殖民主义作为资本殖民，他们越来越难以在前殖民地来产生重大的意义和影响，它开始严重内卷。原来的殖民者包括了盎撒、包括了法兰西、包括了德意志、包括了斯拉夫，整体上他们作为殖民者存在，后来他们开始内卷、开始内耗，盎撒人开始后殖民主义殖民斯拉夫人，甚至开始殖民法兰西人和德意志人。我们要对这个历史的大趋势应有清醒的认识。</p>
<p>13.这是中国处理对外关系，处理对我们的对手、或者是我们的竞争对手、或者是我们敌人的分层的认识，这是一种哲学高度的一种分层的认识，这个认识至关重要。因为它告诉你，为什么他过去是你的敌人，现在是你的朋友，将来是你的伙伴。为什么？因为整个的殖民历史在人类进化的过程中在发生蜕变，我们必须跟着蜕变来调整我们对世界的认识，这样我们才是历史唯物主义者和辩证唯物主义者。好吧，第一个部分我就讲这么多。</p>
<p>14.第二个部分，我想说一点实的，就是俄乌战争的得失，这也是北京的朋友希望我做一点点的点评。我不懂军事，但是对军事斗争做一点点评价，只是一个思考，可能又会引起剧烈的冲突，但不要紧，我说说我的看法。我内心深处最崇拜的伟大的军事家是毛主席，毛主席在战略问题上面从不犯低级错误。什么意思呢？就是毛泽东绝不会在敌人选择的时间、敌人选择的战场和敌人选择的方式与敌人展开军事斗争，毛泽东永远都会在他要的时间、他要的战场和他要的方式展开斗争。</p>
<p>15.换言之，我是普京，战争的时间爆发点应该是2022年的秋冬，而非2022年的早春，这与战略目标的选择是有关系的。你的战略目标是什么？你要的如果是生存空间的话，那么你对乌克兰的处理是灭国、灭军还是部分领土的占领？这是要有清晰的战略目标的。战略目标清晰了，战略选择才能恰当。</p>
<p>16.然而，无论是战略目标如何，无论是战略选择如何，在处理具体的战略实施上面，都不应当犯低级错误。什么叫低级错误？毛泽东的核心军事思想一直是“伤其十指，不如断其一指”，不争夺一城一池的得失，必须集中力量消灭其有生力量，不打消耗战。显然，俄军统帅部在处理乌克兰问题上，无论是他想的是瘫痪也好，无论是他想的是解除军事武装也好，他用的方法都有待于商量。好在大毛这个国力深厚……</p>
<p>17.好在大毛国力深厚，还耗得起。但是，我们对这个他的这个状况是感到不是很满意，我们中国如果要是未来要处理的话，我们会吸取这里边的经验教训。在这个部分，我想介绍一下以色列军事家的一些看法。以色列军事家认为俄乌战争是一场过时的战争，就是它不是这个时代了。他们认为如果中国或者是以色列来打这场战争，不是这样打的。这里边除了战略上选择出现了严重失误以外，也表现出俄军的装备完全没有跟上时代，就是他情报能力极弱、信息战的水平太低。</p>
<p>18.其实在现代的装备方面，当然了，情报能力不完全取决于装备，这个情报能力是取决于一个国家对信息综合处理的能力。像你的战略对手，像乌克兰这样的对手，你的情报到今天这个样子实在说不过去。每一个节点都应该极为清晰，应该在战争初始的二十四小时全部解决完。当然这里边有装备的落后的问题，就是他信息战能力太弱。另外，打击手段落后。这里边提到了中国的天鹰400，就是我们的天鹰400——一个营的火力。天鹰400只是一个火箭炮，但是带制导的火箭炮，射程是400公里，口径是400。我们一个营的天鹰，远远超过俄军一个整装旅。</p>
<p>19.也就是说他的信息战能力不够，打击手段不行。当然了，我们的天鹰是出口给卡塔尔的，出口一个……其实我们有一个营或者一个团已经足以对一个国家构成强大威慑，装备非常重要。当然了，像这种装备必须有强大的信息战能力作为保障，就是空天军的强大程度要必须得极为强大，不然的话这种装备你也没法使。所以我们看到这个战场这种情况，实在是装备差得太远。另外，战役组织拉胯。显然，俄军从总参谋部到战役组织者，他的这些将军们，不行。对战役的理解完全是……</p>
<p>20.对战役的理解、对兵力的运用、对装备的运用完全是50年前的水准，没有进入到二十一世纪。就是，你不知道，从2014年到现在，整整八年的准备，无论是战略选择、无论是装备、无论是战役组织，不行，有可能是这一批的俄国的军事家太弱了。就是他的这个……无论是这个军级、师级和旅一级的这个战役组织能力太拉胯了，出乎我们大家的想象。我们研究了这么多场战争，从来没见过这么拉胯的战役组织。至于战术能力，我们觉得稍好，就是俄军的士兵的水准还有。</p>
<p>21.简单总结，就是一场可以打得非常精彩的战争，由于战略选择、装备落后、战役组织拉胯，打得胶着了。这个即便不是闪击战，也不应该打成这种对垒战或者是持久战。这一场战争进行到今天，这是一个虽未完胜，当然他这个战争的优势还是在，但是打的不好看，就是打的……，不要这样，这样打对整个的俄国的经济整体上的消耗太大。因为俄国是一个进入老龄化的社会，乌克兰也是，这样的战争进行不是最优选择，不是最优选择。</p>
<p>22.另外，考虑到大毛的这种战争潜力和他一向的耐力和他的学习能力，所以我们预计在剩余的战事里边，俄军包括统帅本人普京和俄军的统帅参谋总部和俄军前线将士都会慢慢做出适应战争的调整。虽然乌克兰会获得北约的武装加持，但大体上这一场战争应可达至俄方思考的最低战略要求，就是完成对东部的占领并且完成东西分割，应可达成这样的一个战略目标。</p>
<p>23.今天想重点说一下子对俄乌战争中的金融战的评价。俄乌战争出乎全世界的意料，打得最好的不是军事，而是金融。金融战打得非常漂亮，这里边漂亮有四个层面：第一，俄军，不是俄军，俄国特别是普京总统对俄乌战争导致的金融战进行了八年的有效的准备，包括黄金储备、包括结算系统、包括所有的战略物资的安排，甚至包括未来可能出现的问题都做了充分的准备，有预案，而且准备到位，很了不起的。没想到他……</p>
<p>24.我们几乎所有人都没想到，俄国人在金融这里边有三件事情：第一件事情，俄国有爱国的顶级的金融人才，这让大家非常的惊讶，俄国有爱国的顶级的金融人才，这是第一；第二，俄国有常、一般性国家没有的承担动荡，甚至失败的与敌人进行金融决战的巨大的勇气，这是真的了不起的。多数国家在金融战面前先跪了，腿软。第三个部分，俄国做了充分的物质准备。不仅仅是物质准备，还做了一些制度上的可能的应对方案，超乎我们想象。</p>
<p>25.第二个，俄方对全球金融形势的判断极为精准，这也超乎我们的预料。我们对全球的信用状况、对信用结算系统的理解，可能受盎撒的教育学术传媒的影响，可能深受影响，可能对形势的判断偏于一边倒，而俄方对形势的判断是精准的。所以他们在此判断基础上提出的方案、预案是准确的到位的。第三个，他们有非常优秀的操盘手，他们的操盘及时、精准、到位，非常了不起。</p>
<p>26.第四，俄方在军事斗争上舆论引导太弱了，但是在金融战方面，内外舆论的引导到位和俄国内部老百姓安定，没有出现挤兑抢购；外部舆论引导到位，外部的盟友，特别是一支有金融联系和贸易关系的盟友，保持了战略定力。他的舆论引导是非常到位的，做的非常好。第五，在金融战上面他建立的广泛的统一战线，用八年时间建立起来的金融战的统一战线，或者是某种准联盟关系到位，做得非常好。我们对金融战……</p>
<p>27.我们对金融战的概述将成为我国未来理解金融战和应对金融战非常好的脚本，就是它是一个非常优秀的案例一个脚本。那么有没有做得不好的地方呢？有的。但是我们不说，今天不说，今天不说缺点，尤其是在这个问题上，不说缺点，倒也不是别的意思。其实无论是军事斗争和金融战都给我国以深刻的启发，我们应该有人，我想我国会有专门的班子反复的研究，并且做我国的未来的准备，做我国的准备。</p>
<p>28.俄乌战争的第三个部分，我想谈一下意识形态战争的部分。在这一点上，我们对俄国的处理感到严重失望。这与俄国这些年的情况有关系，就是俄罗斯现在没有伟大的思想家，没有伟大的文学家。既没有伟大的思想家能够穿透历史，给俄乌战争一个具有哲学高度的定性，这一件事情整个俄国竟然做不出来，悲凉。俄国也再也没有像列夫·托尔斯泰那样的，能写出《复活》《战争与和平》的那种文学家或者是思想家。</p>
<p>29.一个被压迫、被凌辱，反抗的民族，对自己发动的战争竟然不能给予解释。我国一定要好好吸取其中的教训，因为解释战争的正义性和合理性，这是发动战争者必须做好的工作。普京曾有两篇长文来解释俄国的历史、来解释战争的合理性、来解释俄乌的关系，但对不起，普京的两篇讲话均无哲学高度，不及格。这里边我国最要注意的就是，除了军事斗争我们吸取经验教训，金融斗争我们吸取教训，最要吸取经验教训的就是意识形态的解释。</p>
<p>30.中国的崛起难道真的是和平崛起吗？一会儿我们会讲台湾问题。如果我们遭遇了不幸，必须使用武力的时候，中国崛起过程中使用军事力量的正义性和合理性，谁来做出具有哲学高度的解释。好多朋友，我知道学了心学的朋友，他懂我在说什么，好多没有学心学的朋友，他们在网上质问我：你有什么资格讨论这些问题？难道国家兴亡不可以匹夫有责吗？他说的资格实际上是奴隶看奴隶主时候自卑的一种态度。</p>
<p>31.普通老百姓不可以讨论战争吗？不可以讨论金融吗？不可以讨论战争的意义吗？我知道很多人说出这个话的时候，他是对权力和对金钱的一种压迫下的那种奴性的自然表达，而且表达奴性的有时候并不是普通老百姓，他可能是贵为领导同志，甚至是部长、行长这一级别。但是那深彻的后殖民主义的奴性贯穿了自己的思想乃至于骨髓，所以他们不思考，也不允许你思考。俄国这一次的战争在这个领域里边非常之糟糕。</p>
<p>32.俄国人内心深处是想带领斯拉夫民族对盎撒，甚至盎撒之外包含了法兰西和德意志一起卷入的后殖民主义、帝国主义的压迫行为，对斯拉夫的压迫行为的一次坚决的反抗，是一次解放。这一件事情说不清楚。当然，你也可以说他笨，或说什么，但不能这样。中华民族必须在未来解释清楚，不但向中国老百姓解释清楚，也要向全世界解释清楚。请记住！这是一种主体性思考，不是站在后殖民主义哲学逻辑上的思考。</p>
<p>33.我们对俄乌战争后续发展做一点点的预判。俄乌战争在军事层面，可能最低要求就是将乌东地区、乌南地区完成占领，并且可能将它划归俄国本土，或者是变成俄国的卫星国。然后可能俄国并无能力去全面占领乌西地区或者是整个乌克兰，其实我个人也认为这是没有必要的，没有必要的。那么乌克兰最后的结局将会呈现一个什么样的状况呢？</p>
<p>34.由于波兰、匈牙利等周边国家对乌克兰领土都有历史的纠葛，可能会有领土要求，将来可能会出现波兰附近的一部分领土，匈牙利部分的一部领土，他们自觉高度自治，归入这些国家。最后乌克兰非常惨烈的局面可能是粉碎了，只会在乌中或者乌西地区留下一块小的地方，一个很小的乌克兰。这是一个国家的悲剧。但这个悲剧后边，让我们看到了后殖民主义的残酷。后殖民主义的野蛮、盎撒帝国的残酷与野蛮。</p>
<p>35.好，这是在军事层面未来的一种状况。在金融层面，由于对俄国的制裁过度使用了信用工具作为武器来进行制裁，所以这个过度使用将会出现严重的反噬。因为过度使用信用工具的时候，触碰了两样东西：第一个是触碰了资本主义的天条。资本主义的天条是什么？私人财产神圣不可侵犯。这是资本主义之所以成立的天条，基础，这一件事情被盎撒打破了。</p>
<p>36.第二个部分，关于国际法的部分。我前些日子说过《罗织经》，中国唐朝来俊臣写过一本《罗织经》。这《罗织经》是一本禁书，非常糟糕。罗织罪名、颠倒黑白，将正义变成邪恶，将邪恶变成正义，将国际法视同玩物。两件事情：一个是破了天条，一个是破了国际法。要知道这两件事情都是一个国际货币的基础。所以美国人挖了一个，为美元、为欧元、为日元、为英镑、为瑞士法郎挖了一个大坑。</p>
<p>37.原本资本殖民的工具是两个：一个叫道德绑架，一个叫军事胁迫。道德绑架主要通过教育、学术、传媒，通过被殖民地的公知、明星和网红来实现道德绑架。我们现在也正在发生类似的事情——道德绑架的事情，大家注意看；第二个方法是军事胁迫。军事胁迫里边有直接的军事打击，有军事同盟，进行带有军事性质的封锁、代理人战争等等。通常资本殖民就是这两个，资本殖民不应使用信用作为武器，一旦资本殖民使用信用作为武器，将激起……</p>
<p>38.将激起被殖民者的激烈反抗。这个反抗不仅仅是军事反抗，也包含了对信用压迫的反抗，所以我们谈卢布起义、卢布起义。为什么俄罗斯卢布按拜登的要求是应该变成废纸，就是它从80跌到150，再跌到250，最后一文不值，然后俄国经济崩溃，这是美国人和英国人划定的路线图。但为什么它又涨回到80，乃至于昨天俄罗斯还要降息？不要加息，降息。回到了战前的水平，还在升值。原因是……</p>
<p>39.原因是我们讲《资本论》的时候讲过信用。信用的三个基础：第一大基础是什么？是道德基础。道德基础实际上是一个国家的信用，其实在这一点上，大国特别是安理会常任理事国是有道德，有最后的道德底线的。所以这些国家不会太离谱，其中俄国由于处在弱势，他极为重视道德，所以他要还款的，他不是赖账不还款的。第二，一个货币的第二个基础是什么呢？就是它的备兑支付能力。什么叫备兑支付能力呢？就是它有没有相对应的东西来形成国际支付。</p>
<p>40.幸运的是俄国是一个大国，他有天然气、有油、有煤炭、有粮食，它可以作为国际支付的手段，甚至以此不够，还做了2300吨的黄金的战略储备。事实证明，物质力量和精神力量同时存在的时候，（我说的信用的第一层是他的道德，第二层是他的物质准备）精神和物质足够的时候，他是可以进行反击的。而且当他放在一个很低的状态下，卢布现在是被严重低估的。他做出了反击，而且这个反击显然是有成效的。第三个基础是交易基础。</p>
<p>41.就是你的货币之所以是被公认的价值尺度，有信用，是必须有其他国家（他者）愿意接纳。显然，俄国在处理联盟关系、在处理国际关系的时候做的还是不错的。所以有人愿意接受卢布，卢比就愿意接受卢布，人民币也愿意接受卢布。很多国家愿意跟你用卢布作为交换手段，没有问题。这个时候SWIFT，所谓的结算、所谓的资本压迫、所谓的信用压迫、所谓的金融攻击，其实在某种意义上就被瓦解了。今天还不能说这一件事情已经成了。</p>
<p>42.但是，他给我们挑开了一扇窗，挑开了一扇窗，他告诉我们，你有足够的精神基础，你有足够的物质准备，你有足够的朋友、联盟，你，是可以挑战的。卢布的这次起义严重地动摇了美元信用、欧元信用、日元信用、英镑信用、瑞士法郎信用的基础，特别是对美元信用构成了一次严重的挑战。要记着，这是第一个揭竿而起，No，说错，对美元挑战的第一个人是戴高乐将军，是法郎，第二次是卢布。今后还会有很多人加入进去。</p>
<p>43.这也意味着我们要对五月风暴做准备了，因为五月美国就要加息和缩表，加息可能会超过0.5，甚至更高，缩表可能是950亿美元每月。那么风暴即将到来。当然了，这跟中国的疫情也是相关联，跟这个战争相关联。因为战争、疫情都赶在这样一个时间节点，然后美国开始开动收割机了，我们五月份将会见到更多更多有趣的事情。因为美国人很清楚，如收割不愉快，那么就必须再燃起战火了。</p>
<p>44.谈到后殖民主义，谈到了对现代性或者现代化的解释。在这里边我想多说两句，我不想批评任何人，但我想多说两句。中国五千万人脱贫，不是现代化？不是现代性吗？不是民主、自由、人权吗？难道美国人五千万人返贫是民主、是自由、是人权吗？我这两天看到在美的华人电台胡说八道，感到非常非常的生气。当然，我也不应该生气。看到海峡旁边那岛上的人说的事情也是让人生气。</p>
<p>45.我们要解释我们的制度的优越性，解释我们制度的民主、自由和人权的关切，我们要有我们自己的解释啊。我们的正义性、合理性和我们的整个的东西，要有解释啊，不能交给别人，不能像俄国此次战争这样的被动。我们不仅仅是要解释战争，要解释一切，包括对新疆棉花的解释，我们要有完整的解释。我国需要像重视芯片专家一样重视我国优秀的思想家、优秀的文学家，让他们来解释。而不是让，</p>
<p>46.而不是……好吧，不说了，再说这个，大概又有意见了。花一点时间谈一下子台海风云、台海风云，这里边有三件事情我要说一下子。这个解释可能又会得罪很多的左边的朋友和右边的朋友，无所谓吧，只是我一个人、我的一孔之见。我不敢说我就对，但很多年很多年的思考，我跟大家汇报一下，总是可以的吧。我现在也写不了文章，也发表不了任何东西，我就念叨几句，因为也无大碍。大家可以争论，也可以引用。</p>
<p>47.我说的也不是我个人的观点，这又是以色列人的观点。其实以色列被我定义为当代军事第四强国，美、中、俄、以色列，它是第四强国，他的军事专家很厉害。我想说什么呢？就是中国在讨论台湾问题的时候，有统派，有急统，有慢统。我们这边没有独，那边是独、独派。但我们考虑的空间，在哲学问题上考虑空间问题不够深刻。怎么理解呢？就是关于台湾问题，中国需要准备五桌菜：第一桌——主桌、大桌是给美国人留着的，因为一旦台海产生军事冲突，基本上是中美军事对决。</p>
<p>48.中美军事对决分两个层级，第一个是常规战争对决，第二个是核战争对决。基本上应局限于常规战争对决，因为核对决，基本上这个世界不见了。那么常规战争对决这第一桌菜，我们准备到什么程度了呢？大家可以相对安心，在西太平洋一千海里半径，中国有阻挡敌人的能力，我用词非常谨慎，阻挡敌人的能力。是否能够全歼呢？这个还不到时候，但我们能挡住它，在一千海里半径，能阻挡。第一桌菜，有准备，但还不到火候。第二桌菜，我们还有四小桌。这二桌菜是给谁准备的呢？这不是我说的。</p>
<p>49.由于美军在日、韩均有军事基地，一旦中美冲突，日韩美军必然参战。日、韩本地军队受美军联合指挥，日韩的本土军队也必然参战。由于日、韩距北京太近，所以第二桌菜是给日韩的。什么意思？按照以方的军事专家的意见，是一个小时之内必须清除掉所有日韩的，包括美军的战略打击能力，一个小时；二十四小时内将日韩去军事化，这是第二桌菜，这桌菜还没准备好。我们有准备，但是这是个空间问题，因为我们太集中精力想台海问题。</p>
<p>50.我们必须将第二桌菜准备到位，准备到位。要知道现在日、韩在全世界的军事强军、强权中排名全部在前十之内，甚至日、韩可能靠前，可能还要再靠前。虽然他们没有核武器，但是他们的军备水平绝对在全球前十之内，所以第二桌菜不轻松。第三桌菜，是新加坡的，不要小看，因为那是马六甲海峡。我们必须拿下马六甲海峡，并且确保南海通道畅通。这第三桌菜不像日韩那么难，但是我们的航母舰队基本是为这个做准备的。第四桌菜，</p>
<p>51.第四桌菜，小桌啊。大桌一桌，小桌一共四桌。这第四桌就是小桌里边的第三桌，是为印度准备的，就是我们必须确保印度洋方向安全。这一桌菜倒不需要那么大。第五桌菜也是四小桌里边的最后一桌，是为台湾准备的。所以好多人讨论台海，它是第五桌菜。如果前四桌没准备到位，天天嚷嚷第五桌菜的时候，你可能会将你的国家陷入到一种极为被动的局面。我们不言战争，但我们要请客，就要把菜准备好；如果你没准备好，想都没想明白，别瞎嚷嚷。</p>
<p>52.很多朋友说，可能会有人触碰我们的底线哦。比如说，某大国与台湾建交，打还是不打？比如说，台湾岛上公投、独立，打还是不打？我想说的是，我想说的是：请记住毛主席的教导，我们在我们选择的空间，我们在我们选择的时间，我们用我们选择的方式，进行我们中华民族的反对帝国主义、反对殖民主义的解放战争，这个解放战争绝不仅限于台湾，包含了日、韩、新以及其他。</p>
<p>53.如，中国在周边用兵，则意味着持续五百年的西方殖民历史将彻底终结。不用兵则已，一旦用兵，意味着持续五百年的殖民历史彻底终结。其实在讨论中国的军事安全问题的时候，我们考虑的是东亚的一体化，考虑的是未来整个全球政治重心向中国转移的问题，东亚的经济、政治中心向……比如说，向香港转移和未来全球政治、经济文化中心的转移问题，不仅仅考虑台湾的一个问题。如有人制造某种，</p>
<p>54.如，有某国制造像乌克兰事件引我们在他设定的时间和他设定的战场和他设定的方式进行某场战争的时候，请记住毛主席的话，也请大家记住今天下午的聊天。我们做我们的选择，我们来选择空间，打谁——我们五桌饭，吃哪一桌是我们的事情，好不好？我们选择时间，我们选择战争的方式。说到战争的方式，其实非常残酷、非常残酷。我们虽然拥有了一定的精确制导武器，我们拥有了信息战的能力，拥有精确制导武器，但面对惨烈的敌人，我们也会采取同样惨烈的方式。</p>
<p>55.我多说两句。我最怕看的样板戏是《杜鹃山》，其中我最讨厌的人是温其久。温其久劝雷刚下山，下了山就被敌人团灭。还好有个政委、有个党代表柯湘识破了阴谋，不下山。既要消灭敌人，也不按他们的要求下山报仇，对吧？我们要有柯湘的智慧，我们不能像雷刚似的。所以有好多人天天嚷嚷的台海问题什么的，不要做温其久，以为这样好像显得很正义、显得很爱国，错啦，要听毛主席的话，在我们选择的空间、我们选择时间，用我们的方式，</p>
<p>56.用我们的方式完成中华民族反对帝国主义和殖民主义的解放战争。记着：关于周边战争，我们对战争的定性是中华民族反对帝国主义和殖民主义的解放战争，是解放战争。如果有些人成为所谓的台独等等等等，他们不再是中华民族的一份子，那么战争使用的方式就应该是解放战争的正义的、严厉的、有力的方式。</p>
<p>57.最后我想说几句，我认为我国最近在政治上面，特别是在处理周边关系上面做得非常好。举例，阿富汗，我国在处理阿富汗问题上，确实在政治和外交方面表达了极高的水准。就是我国周边可能会出现一个四千万人口的伟大的伊斯兰社会主义共和国，这个很了不起，做得很好的。我国跟这个周边关系处理得、在某种意义上比俄罗斯处理得更好，一点一点地在走出历史的迷雾。就比如说，我们用人民币借给阿富汗，作为阿富汗可以发人民币主权债券来重建阿富汗,甚至这个模式可以伊朗、土耳其都可以用啊。</p>
<p>58.我国不再采取以往的这种事情。我其实在平台上讲心学讲了很久了，我也只能跟平台上你们——我的好朋友们这样的聊。我很担心一个大国的政治家有受害者的心态，有被压迫者和受害者的心态，而无治理者的眼界和胸怀。我刚才说空间了，我们是五桌菜；我说了时间了，我们是2049年完成东亚重心和全球重心的转移；我说了空间和时间，我说了方式、说了方式。我们不是受害者，已经过了，我们现在是全球的治理者，我们的主体性意味着人类光明的未来。</p>
<p>59.须知，早在西周，我国政治家已经有了天下观，我国的领导人叫“天子”。我们是有天下观的，天下观是高于国家的。我国曾被帝国主义和殖民主义欺负的非常之惨烈，至今遗留的伤痛仍在，例如外蒙古、例如远东、例如台湾，等等等等。伤口并未愈合，但我们依旧在此基础上要有天子观、有天下观，以此来解决问题。</p>
<p>60.最后多说两句关于台湾的看法。我注意到岛上和内地的激烈的情绪对立和对撞。我今天想说台湾对于我们的价值，虽然有一天我们可能不得已要采取极端手段，但我还是要说一下台湾对中国的意义很大。因为我们改革开放借用了台湾的资本和技术，台湾是政治上的一块很好的试验田，给了我们很多的借鉴。台湾承担着中国主体性的第三方监督的责任——他们的批评虽尖锐，有时候非常重要；台湾依旧是中国与一些其他国家沟通的桥梁；台湾依旧是中华民族文化的，</p>
<p>61.台湾依旧是中华民族文化的存储器。历史有它伤痛的部分，比如说香港、澳门、台湾——港澳台，它有它的伤痛。但你知道，任何事物都是辩证的，它有正反两个方向的存在。我们一定会完成中华民族的伟大的统一，甚至这个统一远远超过台湾。但，记着：我们的“统”不是一般意义上的现代性、现代国家的“统”，而是天下观的“统”。如此，我们才能有中华民族未来在本世纪下半个世纪傲立于世界民族之林的高度。</p>
<p>62.今天就聊这么多，其实聊得我有点小小的激动。原本应该加几句“五月风暴”的内容——关于加息和缩表。哎，没劲了，谈不动了。下个星期是讲《资本论》，不是，是讲《通论》的第二讲。《通论》的第二讲挺折磨人的，因为我们上次是讲的是近代思想史，第二讲是讲现代思想史，我还没准备好呢。“五月风暴”呢，要加息要缩表，好多朋友说看不懂，我提示一下吧。</p>
<p>63.你说，加息缩表是减负债呢还是减资产呢？如果资产负债表是均衡的，那么缩负债也就必然缩资产。那么，如你是耶伦，你打算缩谁的资产？谁家的资产？哪一类型的资产？我说清楚了吧？当你进行一个全盘性思考的时候，可能大体上你就知道可能要发生的事情和正在发生的事情。好吧，今天就聊这么多，我想休息一会儿。明天下午三点钟，有什么我们再做补充，明天见。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于WPF的xaml]]></title>
        <id>https://zivkidd.github.io/post/guan-yu-wpf-de-xaml/</id>
        <link href="https://zivkidd.github.io/post/guan-yu-wpf-de-xaml/">
        </link>
        <updated>2021-03-31T13:38:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-wpf项目">1. wpf项目</h1>
<ol>
<li>App.xaml分支:程序的主体。大家知道，在 Windows系统里，一个程序就是一个进程(Process)。Windows还规定，一个GUI进程需要有一个窗体(Window)作为“主窗体”。App.xaml文件的作用就是声明了程序的进程会是谁，同时指定了程序的主窗体是谁。在这个分支里还有一个文件——App.xaml.cs，它是App.xaml的后台代码。</li>
<li>MainWindow.xaml分支:程序的主窗体。</li>
</ol>
<h1 id="2-xamlextensible-application-markup-language的最基本构成">2. xaml(extensible application markup language)的最基本构成</h1>
<pre><code class="language-xml">&lt;Window x:Class=&quot;WpfApp2.MainWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
        xmlns:local=&quot;clr-namespace:WpfApp2&quot;
        mc:Ignorable=&quot;d&quot;
        Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt;
    &lt;Grid&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>
<p>XAML是一种由XML派生而来的语言，所以很多XML中的概念在XAML是通用的。比如,使用标签声明一个元素（每个元素对应内存中的一个对象）时，需要使用起始标签&lt;Tag&gt;和终止标签&lt;/Tag&gt;，夹在起始标签和终止标签中的XAML 代码表示是隶属于这个标签的内容。如果没有什么内容隶属于某个标签，则这个标签称为空标签，可以写为&lt;Tag/&gt;。</p>
<h1 id="3-关于xmlns">3. 关于xmlns</h1>
<p>xmlns（xml-namespace）是在定义名称空间（namespace）<br>
xmIns[:可选的映射前缀]=&quot;名称空间&quot;</p>
<pre><code class="language-xml">xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
</code></pre>
<p>这一句没有加冒号，说明没有映射前缀，那么来自于这个命名空间的标签都不用加前缀，比如grid，如果改成</p>
<pre><code class="language-xml">xmlns:n=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
</code></pre>
<p>那么整个变成</p>
<pre><code class="language-xml">&lt;n:Window x:Class=&quot;WpfApp2.MainWindow&quot;
        xmlns:n=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
        xmlns:local=&quot;clr-namespace:WpfApp2&quot;
        mc:Ignorable=&quot;d&quot;
        Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt;
    &lt;n:Grid&gt;

    &lt;/n:Grid&gt;
&lt;/n:Window&gt;
</code></pre>
<p>为什么名称空间看上去像是一个主页地址呢?其实把它copy到E的地址栏里尝试跳转也不会打开网页。这里只是XAML解析器的一个硬性编码( hard-coding)，只要见到这些固定的字符串，就会把一系列必要的程序集（Assembly)和程序集中包含的.NET名称空间引用进来。</p>
<h1 id="4-xaml中引用类库">4. xaml中引用类库</h1>
<p>把类库引用到项目中是引用其中名称空间的物理基础，尤论是C#还是XAML都是这样。一旦将一个类库引用进程序，就可以引用其中的名称空间。假攻找的类库程序集名为MyLibrary.dl，其中包含Common和 Controls 两个名称空间，而且已经把这个程序集引用进WPF项目，那么在XAML中引用这两个名称空间的语法是:</p>
<pre><code class="language-xml">xmIns:映射名=&quot;clr-namespace:类库中名称空间的名字;assembly=类库文件名
xmins:common=&quot;clr-namespace:Common;assembly=MyLibrary&quot;
xmins:controls-&quot;clr-namespace:Controls;assembly=MyLibrary&quot;
</code></pre>
<p>比如：</p>
<pre><code class="language-xml">xmlns:yui=&quot;clr-namespace:YUI.WPF.YProperties;assembly=YUI.WPF&quot;
</code></pre>
<p>一旦我们将类库中的名称空间引用XAML文档，我们就可以使用这些名称空间里的类。语法格式是:<br>
<code>&lt;映射名:类名&gt;.….&lt;/映射名:类名&gt;</code><br>
例如使用Common和 Controls 中的类，代码是这样:</p>
<pre><code class="language-xml">&lt;common:MessagePanel x:Name=&quot;window1&quot;/&gt;
&lt;controls:LedButton x:Name=&quot;button1&quot;/&gt;
</code></pre>
<h1 id="5-x命名空间">5. x命名空间</h1>
<p>x名称空间里的成员（如x:Class、x:Name)是专门写给XAML编译器看、用来引导XAML编译器把XAML 代码编译成CLR代码的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">种类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x:Array</td>
<td style="text-align:center">标签扩展</td>
</tr>
<tr>
<td style="text-align:center">x:Class</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Classmodifier</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Code</td>
<td style="text-align:center">XAML指令元素</td>
</tr>
<tr>
<td style="text-align:center">x:FieldModifier</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Key</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Name</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Null</td>
<td style="text-align:center">标签扩展</td>
</tr>
<tr>
<td style="text-align:center">x:Shared</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Static</td>
<td style="text-align:center">标签扩展</td>
</tr>
<tr>
<td style="text-align:center">x:Subclass</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Type</td>
<td style="text-align:center">标签扩展</td>
</tr>
<tr>
<td style="text-align:center">x:TypeArguments</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:Uid</td>
<td style="text-align:center">Attribute</td>
</tr>
<tr>
<td style="text-align:center">x:XData</td>
<td style="text-align:center">XAML指令元素</td>
</tr>
</tbody>
</table>
<h2 id="51-xname">5.1  x:Name</h2>
<p>x:Name 的作用有两个:<br>
(1)告诉XAML编译器，当一个标签带有x:Name时除了为这个标签生成对应实例外还要为这个实例声明一个引用变量，变量名就是x:Name的值。<br>
(2)将XAML标签所对应对象的Name 属性（如果有）也设为x:Name的值，并把这个值注册到UI树上，以方便查找。<br>
经常会有初学者问:在XAML代码中是应该使用Name呢，还是 x:Name? Name属性定义在FrameworkElement类中，这个类是WPF 控件的基类，所以所有WPF 控件都具有Name这个属性。当一个元素具有Name属性时,你使用Name或x:Name效果是一样的。比如&lt;Button x:Name=&quot;btn&quot;&gt;和&lt;Button Name=&quot;btn&quot;&gt;，XAML编译器的动作都是声明名为btn的 Button类型变量并引用一个Button类型实例，而且此实例的Name属性值亦为 btn。此时，Name和 x:Name是可以互换的，只是不能同时出现在一个元素中。对于那些没有Name属性的元素，为了在XAML声明时也创建引用变量以便在C#代码中访问，我们就只能使用x:Name。因为x:Name的功能涵盖了Name属性的功能，所以<strong>全部使用x:Name以增强代码的统一性和可读性</strong>。</p>
<h2 id="52-xfieldmodifier">5.2  x:FieldModifier</h2>
<p>使用x:Name后，XAML标签对应的实例就具有了自己的引用变量，而且这些引用变量都是类的字段。既然是类的字段就免不了要关注一下它们的访问级别。默认情况下，这些字段的访问级别按照面向对象的封装原则被设置成了internal。在编程的时候，有时候我们需要从一个程序集访问另一个程序集中窗体的元素，这时候就需要把被访问控件的引用变量改为public级别，x:FieldModifier就是用来在XAML里改变引用变量访问级别的。<br>
如果这样声明一个窗体中的控件:</p>
<pre><code class="language-xml">&lt;StackPanel&gt;
&lt;TextBox x:Name=&quot;textBox1&quot; x:FieldModifier=&quot;public&quot; Margin=&quot;5&quot;/&gt;
&lt;TextBox x:Name=&quot;textBox2&quot; x:FieldModifier=&quot;public&quot; Margin=&quot;5&quot;/&gt;
&lt;TextBox x:Name=&quot;textBox3&quot; Margin=&quot;5&quot;&gt;
&lt;/StackPanel&gt;
</code></pre>
<p>textBox1和 textBox2的访问级别被设置为public，而textBox3的访问级别仍为默认的 internal(即程序集级别)。<br>
<strong>因为x:FieldModifer是用来改变引用变量访问级别的，所以使用x:FieldModifier的前提是这个标签同时也使用x:Name,不然何来的引用变量呢?</strong></p>
<h1 id="6-布局元素">6. 布局元素</h1>
<h2 id="61-grid网格">6.1  Grid:网格</h2>
<p>可以自定义行和列并通过行列的数量、行高和列宽来调整控件的布局。近似于HTML中的Table。<br>
<strong>Grid的特点如下:</strong><br>
可以定义任意数量的行和列，非常灵活。<br>
行的高度和列的宽度可以使用绝对数值、相对比例或自动调整的方式进行精确设定，并可设置最大和最小值。<br>
内部元素可以设置自己的所在的行和列，还可以设置自己纵向跨几行、横向跨几列。可以设置Children元素的对齐方向。<br>
<strong>基于这些特点，Grid适用的场合有:</strong><br>
UI布局的大框架设计。<br>
大量U元素需要成行或者成列对齐的情况。<br>
UI整体尺寸改变时，元素需要保持固有的高度和宽度比例。UI后期可能有较大变更或扩展。<br>
<img src="https://zivkidd.github.io/post-images/1617198236583.png" alt="" loading="lazy"><br>
<strong>对于Grid的行高和列宽，我们可以设置三类值:</strong><br>
绝对值: double数值加单位后缀（如上例)。<br>
比例值: double数值后加一个星号(“*”)。<br>
自动值:字符串 Auto。<br>
<strong>为控件指定行和列遵循以下规则:</strong><br>
行和列都是从0开始计数。<br>
指定一个控件在某行，就为这个控件的标签添加Grid.Row=&quot;行编号&quot;这样一个Attribute，若行编号为0（即控件处于首行）则可省略这个Attribute.<br>
指定一个控件在某列，就为此控件添加Grid.Column=&quot;列编号&quot;这样的Attribute，若列编号为0则Attribute可以省略不写.<br>
若控件需要跨多个行或列，请使用Grid.RowSpan=&quot;行数&quot;和Grid.ColumnSpan=&quot;列数&quot;两个Attribute.<br>
<strong>可以用GridSplitter做可拖拽的分隔栏</strong></p>
<h2 id="62-stackpanel栈式面板">6.2  StackPanel:栈式面板</h2>
<p>可将包含的元素在竖直或水平方向上排成一条直线，<strong>当移除一个元素后，后面的元素会自动向前移动以填充空缺</strong>。<br>
StackPanel可以把内部元素在纵向或横向上紧凑排列、形成栈式布局，通俗地讲就是把内部元素像垒积木一样“撂起来”。垒积木大家都玩过，当把排在前面的积木块抽掉之后排在它后面的元素会整体向前移动、补占原有元素的空间。<br>
<strong>基于这个特点，StackPanel适合的场合有:</strong><br>
同类元素需要紧凑排列（如制作菜单或者列表)。<br>
移除其中的元素后能够自动补缺的布局或者动画。</p>
<h2 id="63-canvas画布">6.3  Canvas:画布</h2>
<p>内部元素可以使用以像素为单位的绝对坐标进行定位，类似于WindowsForm编程的布局方式。<br>
Canvas译成中文就是“画布”，显然，在Canvas里布局就像在画布上画控件一样。使用Canvas布局与在Windows Form窗体上布局基本上是一样的，只是在 Windows Form开发时我们通过设置控件的Left和Top等属性来确定控件在窗体上的位置，而WPF 的控件没有Left和Top等属性，就像把控件放在Grid里时会被附加上 Grid.Column和 Grid.Row属性一样，当控件被放置在 Canvas里时就会被附加上 Canvas.X和Canvas.Y属性。<br>
Canvas很容易被从Windows Form迁移过来的程序员所滥用,实际上大多数时候我们都可以使用Grid或StackPanel等布局元素产生更简洁的布局。<br>
<strong>Canvas适用的场合包括:</strong><br>
一经设计基本上不会再有改动的小型布局（如图标)。<br>
艺术性比较强的布局。<br>
需要大量使用横纵坐标进行绝对点定位的布局。<br>
依赖于横纵坐标的动画。</p>
<h2 id="64-dockpanel泊靠式面板">6.4  DockPanel:泊靠式面板</h2>
<p>内部元素可以选择泊靠方向，类似于在 Windows Form编程中设置控件的Dock属性。</p>
<h2 id="65-wrappanel自动折行面板">6.5  WrapPanel:自动折行面板</h2>
<p>内部元素在排满一行后能够自动折行，类似于HTML 中的流式布局。<br>
<img src="https://zivkidd.github.io/post-images/1617198468345.png" alt="" loading="lazy"></p>
<h1 id="7-binding">7. Binding</h1>
<p>数据源是一个对象，一个对象身上可能有很多数据，这些数据又通过属性暴露给外界。那么，其中哪个数据是你想通过Binding送达UI元素的呢?换句话说，UI上的元素关心的是哪个属性值的变化呢?这个属性就称为Binding 的路径(<strong>Path</strong>)。但光有属性还不行——Binding是一种自动机制，当值变化后属性要有能力通知Binding，让 Binding 把变化传递给UI元素。怎样才能让一个属性具备这种通知Binding值已经变化的能力呢？方法是在属性的set 语句中激发一个PropertyChanged事件。这个事件不需要我们自己声明，我们要做的是让作为数据源的类实现System.ComponentModel名称空间中的INotifyPropertyChanged接口。当为 Binding 设置了数据源后，Binding就会自动侦听来自这个接口的PropertyChanged事件。<br>
实现了INotifyPropertyChanged接口的 Student类看起来是这样:</p>
<pre><code class="language-csharp">class Student : INotifyPropertyChanged
{
	public event PropertyChangedEventHandler PropertyChanged;
	private string name;
	public string Name
    {
		get { return name; }
        set{name=value;}
		//激发事件
		if (this.PropertyChanged != null)
		{
    		this.PropertyChanged.Invoke(this,new PropertyChangedEventArgs(&quot;Name&quot;));
		}
    }
}
</code></pre>
<p>经过这样一升级，当Name属性的值发生变化时PropertyChanged事件就会被激发，Binding接收到这个事件后发现事件的消息告诉它是名为Name的属性发生了值的改变,于是就会通知Binding目标端的UI元素显示新的值。</p>
<p>在c#代码中绑定：</p>
<pre><code class="language-csharp">//准备数据源
stu =new Student();
//准备Binding
Binding binding = new Binding();
binding.Source = stu;
binding.Path= new PropertyPath(&quot;Name&quot;);
//使用 Binding连接数据源与 Binding目标
BindingOperations.SetBinding(this.textBoxName, TextBox.TextProperty, binding);
</code></pre>
<p>在准备Binding 的部分，先是用“Binding binding = new Binding();”声明Binding类型变量并创建实例，然后使用“binding.Source = stu;”为Binding实例指定数据源，最后使用“binding.Path=new PropertyPath(&quot;Name&quot;);”语句为Binding 指定访问路径。<br>
把数据源和目标连接在一起的任务是使用“BindingOperations.SetBinding(...)”方法完成的。</p>
<p><strong>这个方法的3个参数是我们记忆的重点:</strong><br>
<strong>第一个参数</strong>用于指定 Binding的目标，本例中是this.textBoxName。<br>
与数据源的Path原理类似，<strong>第二个参数</strong>用于为 Binding 指明把数据送达目标的哪个属性。只是你会发现在这里用的不是对象的属性而是类的一个静态只读( static readonly)的DependencyProperty类型成员变量！这就是我们后面要详细讲述的与Binding 息息相关的依赖属性。其实很好理解，这类属性的值可以通过Binding 依赖在其他对象的属性值上,被其他对象的属性值所驱动。<br>
<strong>第三个参数</strong>很明了，就是指定使用哪个Binding实例将数据源与目标关联起来。<br>
<img src="https://zivkidd.github.io/post-images/1617198629569.png" alt="" loading="lazy"></p>
<p>在xaml中相互绑定（把textbox的text属性与slider的value关联）：</p>
<pre><code class="language-csharp">&lt;Window x:Class=&quot;WpfApplication1.Window1&quot;
		xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
		xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; 
        Title=&quot;Control as Source&quot;
		Height=&quot;110&quot;Width=&quot;300&quot;&gt;
	&lt;StackPanel
		&lt;TextBox x:Name=&quot;textBox1&quot; Text=&quot;{Binding Path=Value,ElementName=slider1}&quot;BorderBrush=&quot;Black&quot;
Margin=&quot;5&quot;/&gt;
		&lt;Slider x:Name=&quot;slider1&quot; Maximum=&quot;100&quot; Minimum=&quot;0&quot; Margin=&quot;5&quot;/&gt;
    &lt;/StackPanel&gt;
&lt;/Window&gt;
</code></pre>
<pre><code class="language-csharp">Text=&quot;{Binding Path=Value,ElementName=slider1}&quot;
</code></pre>
<p>因为Binding 类的构造器本身可以接收Path作为参数，也可以写作：</p>
<pre><code class="language-csharp">Text=&quot;{Binding Value,ElementName=slider1}&quot;
</code></pre>
<p>因为在C#代码中我们可以直接访问控件对象，所以一般也不会使用Binding 的 ElementName 属性，而是直接把对象赋值给Binding 的Source属性。</p>
<p>控制Binding数据流向的属性是Mode，它的类型是BindingMode枚举。<strong>BindingMode</strong>可取值为TwoWay、OneWay、OnTime、OneWayToSource和Default。这里的Default值是指Binding 的模式会根据目标的实际情况来确定，比如若是可编辑的(如TextBox.Text属性)，Default就采用双向模式;若是只读的（如TextBlock.Text）则采用单向模式。</p>
<p>空间属性Binding 的另一个属性——<strong>UpdateSourceTrigger</strong>，它的类型是UpdateSourceTrigger枚举，可取值为PropertyChanged、LostFocus、Explicit和Default。显然，对于TextBox默认值Default 的行为与LostFocus一致，我们只需要把这个属性改为PropertyChanged，则 Slider 的手柄就会随看我们在1extBOX里的制入m以变位置。</p>
<p><strong>binding到不同对象</strong></p>
<p>Binding的源是数据的来源，所以，只要一个对象包含数据并能通过属性把数据暴露出来，它就能当作 Binding 的源来使用。包含数据的对象比比皆是，但必须为Binding 的Source 指定合适的对象Binding才能正确工作，常见的办法有:</p>
<ol>
<li>
<p>把<strong>普通CLR类型单个对象</strong>指定为Source:包括.NET Framework自带类型的对象和用户自定义类型的对象。如果类型实现了INotifyPropertyChanged 接口，则可通过在属性的 set语句里激发PropertyChanged事件来通知 Binding数据已被更新。</p>
</li>
<li>
<p>把<strong>普通CLR集合类型对象</strong>指定为Source:包括数组、List&lt;T&gt;、ObservableCollection&lt;T&gt;等集合类型。实际工作中，我们经常需要把一个集合作为ItemsControl派生类的数据源来使用，一般是把控件的ItemsSource属性使用Binding 关联到一个集合对象上。</p>
<p>在使用集合类型作为列表控件的ltemsSource时一般会考虑使用ObservableCollection&lt;T&gt;代替List&lt;T&gt;，因为ObservableCollection&lt;T&gt;类实现了INotifyCollectionChanged和INotifyPropertyChanged接口，能把集合的变化立刻通知显示它的列表控件，改变会立刻显现出来。</p>
<p><strong>将listbox的数据绑定到数组：</strong></p>
<pre><code class="language-csharp">public Window1()
{
    InitializeComponent();
	//准备数据源
    List&lt;Student&gt; stuList = new List&lt;Student&gt;()
    {
    	new Student(){id=0, Name=&quot;Tim&quot;, Age=29},
        new Student(){id=1, Name=&quot;Tom&quot;, Age=28},
        new Student(){id=2, Name=&quot;Kyle&quot;, Age=27},
        new Student(){id=3, Name=&quot;Tony&quot;, Age=26},
        new Student(){id=4, Name=&quot;Vina&quot;, Age=25},
        new Student(){id=5, Name=&quot;Mike&quot;, Age=24},
    };
    //为ListBox 设置 Binding
    this.listBoxStudents.ItemsSource = stuList;
    this.listBoxStudents. DisplayMemberPath = &quot;Name&quot;;
    //为TextBox设置 Binding
    Binding binding = new Binding(&quot;SelectedItem.id&quot;){Source = this.listBoxStudents};
    this.textBoxld.SetBinding( TextBox.TextProerty, binding);
}
</code></pre>
</li>
<li>
<p>把<strong>ADO.NET 数据对象</strong>指定为Source:包括DataTable和 DataView等对象。</p>
</li>
<li>
<p>使用XmlDataProvider把 <strong>XML数据</strong>指定为Source:XML作为标准的数据存储和传输格式几乎无处不在，我们可以用它表示单个数据对象或者集合;些WPF控件是级联式的(如TreeView和 Menu)，我们可以把树状结构的XML 数据作为源指定给与之关联的Binding。</p>
</li>
<li>
<p>把依赖对象(Dependency Object)指定为Source:依赖对象不仅可以作为 Binding 的目标，同时也可以作为Binding 的源。这样就有可能形成Binding链。依赖对象中的依赖属性可以作为 Binding的 Path。</p>
</li>
<li>
<p>把容器的DataContext指定为Source (WPF Data Binding的默认行为):有时候我们会遇到这样的情况—我们明确知道将从哪个属性获取数据，但具体把哪个对象作为 Binding源还不能确定。这时候，我们只能先建立一个 Binding、只给它设置Path而不设置Source,让这个Binding自己去寻找Source。这时候，Binding 会自动把控件的DataContext当作自己的Source(它会沿着控件树一层一层向外找,直到找到带有Path指定属性的对象为止)。通过ElementName指定Source:在C#代码里可以直接把对象作为Source赋值给Binding,但XAML无法访问对象，所以只能使用对象的Name属性来找到对象。</p>
</li>
<li>
<p>通过Binding的 RelativeSource属性相对地指定Source:当控件需要关注自己的、自己容器的或者自己内部元素的某个值就需要使用这种办法。</p>
</li>
<li>
<p>把ObjectDataProvider对象指定为Source:当数据源的数据不是通过属性而是通过方法暴露给外界的时候，我们可以使用这两种对象来包装数据源再把它们指定为Source。</p>
</li>
<li>
<p>把使用<strong>LINQ检索得到的数据</strong>对象作为Binding的源。</p>
</li>
</ol>
<p><strong>binding的数据转换</strong></p>
<p>Binding还有另外一种机制称为数据转换(Data Convert)，当Source端Path所关联的数据与Target端目标属性数据类型不一致时，我们可以添加数据转换器(Data Converter)。上面提到的问题实际上是double类型与string 类型互相转换的问题，因内处理咫木比权间中，2次些1人库就自动替我们做了。但有些类型之间的转换就不是WPF能替我们做的了，例如下面这些情况:</p>
<ol>
<li>Source里的数据是Y、N和X三个值(可能是char类型、 string类型或自定义枚举类型),UI 上对应的是CheckBox控件，需要把这三个值映射为它的 IsChecked属性值（boo1?类型)。</li>
<li>当TextBox里已经输入了文字时用于登录的Button才会出现,这是string类型与Visibility枚举类型或bool类型之间的转换(Binding 的 Mode将是OneWay)。</li>
<li>Source里的数据可能是Male 或Female ( string或枚举)，UI上对应的是用于显示头像的Image控件，这时候需要把Source里的值转换成对应的头像图片URI(亦是OneWay)。</li>
</ol>
<p>当遇到这些情况时，我们只能目己动手写Converter，方法是创建一个类并让这个类实现IValueConverter接口。IValueConverter接口定义如下:</p>
<pre><code class="language-csharp">public interface IValueConverter
{
	object Convert(object value, Type targetType, object parameter, CultureInfo culture);
	object ConvertBack(object value,Type targetType, object parameter, Culturelnfo culture);
}
</code></pre>
<h1 id="8模板">8.模板</h1>
<p>在WPF中，通过引入模板（Template)微软将数据和算法的“内容”与“形式”解耦了。WPF中的Template分为两大类:</p>
<p><strong>ControlTemplate</strong>是算法内容的表现形式，一个控件怎样组织其内部结构才能让它更符合业务逻辑、让用户操作起来更舒服就是由它来控制的。它决定了控件“长成什么样子”，并让程序员有机会在控件原有的内部逻辑基础上扩展自己的逻辑。</p>
<p><strong>DataTemplate</strong>是数据内容的表现形式，一条数据显示成什么样子，是简单的文本还是直观的图形动画就由它来决定。</p>
<p>一言蔽之，Template就是“外衣”——ControlTemplate是控件的外衣DataTemplate是数据的外衣。</p>
<p><strong>实际项目中，ControlTemplate 主要有两大用武之地:</strong></p>
<p>通过更换ControlTemplate改变控件外观，使之具有更优的用户使用体验及外观。</p>
<p>借助ControlTemplate，程序员与设计师可以并行工作，程序员可以先用WPF标准控件进行编程，等设计师的工作完成后，只需把新的ControlTemplate应用到程序中就可以了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python连接SQL Server数据库]]></title>
        <id>https://zivkidd.github.io/post/python-lian-jie-sql-server-shu-ju-ku/</id>
        <link href="https://zivkidd.github.io/post/python-lian-jie-sql-server-shu-ju-ku/">
        </link>
        <updated>2021-03-31T13:36:14.000Z</updated>
        <content type="html"><![CDATA[<p>通常有两个库推荐，pyodbc和pymssql，pymssql对中文非常不友好<br>
使用pyodbc之前在电脑搜索odbc数据源管理程序<br>
<img src="https://zivkidd.github.io/post-images/1617197811890.png" alt="" loading="lazy"><br>
点击添加新数据源<br>
这里会显示可用的数据源的驱动程序<br>
然后就可以在python里</p>
<pre><code class="language-python">import pyodbc
conn = pyodbc.connect('DRIVER={数据源的驱动程序如SQL Server Native Client 11.0};SERVER=IP;DATABASE=数据库名称;UID=用户名;PWD=密码')
cur=conn.cursor()
cur.execute('select top 1000 * from [dbo].[ZJB_TaskInfo]')
results=cur.fetchall()
</code></pre>
<p>这样就可以通过发送sql语句与数据库进行交互</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用shapefile切割遥感影像对应区域——QGIS与python gdal结合]]></title>
        <id>https://zivkidd.github.io/post/li-yong-shapefile-qie-ge-yao-gan-ying-xiang-dui-ying-qu-yu-qgis-yu-python-gdal-jie-he/</id>
        <link href="https://zivkidd.github.io/post/li-yong-shapefile-qie-ge-yao-gan-ying-xiang-dui-ying-qu-yu-qgis-yu-python-gdal-jie-he/">
        </link>
        <updated>2021-03-31T13:34:27.000Z</updated>
        <content type="html"><![CDATA[<p>主要要做的就是有一个大的tif，可能长20w个像素，宽10w个像素这种，然后给一些shp文件，按shp文件切割得到对应的图像分割训练需要的image和mask</p>
<h1 id="第一步就是mask怎么生成">第一步就是mask怎么生成</h1>
<ol>
<li>可以先在QGIS里用shp生成对应的影像，把shapefile转换成和对应影像同样分辨率、同样边界的影像（这个对于非常大的影像是很有用的，因为这时不可能在内存里生成一张那么大的影像，只能是先生成tif）<br>
<img src="https://zivkidd.github.io/post-images/1617197739362.png" alt="" loading="lazy"></li>
<li>可以直接在python里把shape画出来，适用于比较小的影像，这样可以少一些在qgis的操作</li>
</ol>
<h1 id="第二步就是在python里切割">第二步就是在python里切割</h1>
<ol>
<li>可以用pyshp读shape文件（路径不能包含中文），用gdal读遥感影像（gdal在conda中装会比较容易成功，conda install gdal）</li>
</ol>
<p>有一些python处理的脚本可以看看<a href="https://github.com/ZivKidd/GIS_TIFF_SHP_process">github地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于GNSS和RTK]]></title>
        <id>https://zivkidd.github.io/post/guan-yu-gnss-he-rtk/</id>
        <link href="https://zivkidd.github.io/post/guan-yu-gnss-he-rtk/">
        </link>
        <updated>2021-03-31T13:33:45.000Z</updated>
        <content type="html"><![CDATA[<p>RTK采用的实时定位技术，可以在流动站随时看到测量点的坐标以及精度情况；PPK定位属于后处理定位,在现场看不到点的坐标，需要事后处理才能看到结果。<br>
来自 <a href="https://www.sohu.com/a/247375413_769730">https://www.sohu.com/a/247375413_769730</a><br>
RTK可以自己架基站在已知点上，或者连接cors，千寻的cors价格在2000/年，可以全国通用，但在连cors时初始化需要比较久，在树木遮挡下有时候很差，所以用自己的基站比较好，精度基本在水平2cm，高度4cm<br>
PPK不能用cors，要两个接收机，一个做基站，一个流动站，但是需要后期解算，精度很高，能到毫米</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用libtiff.net进行BigTiff的读写]]></title>
        <id>https://zivkidd.github.io/post/li-yong-libtiffnet-jin-xing-bigtiff-de-du-xie/</id>
        <link href="https://zivkidd.github.io/post/li-yong-libtiffnet-jin-xing-bigtiff-de-du-xie/">
        </link>
        <updated>2021-03-31T13:28:55.000Z</updated>
        <content type="html"><![CDATA[<p>读入多张tif影像水平拼接成bigtiff</p>
<pre><code class="language-csharp">using (Tiff bigTiff = Tiff.Open(@&quot;D:\desktop\test\新建文件夹 (17)\5.tif&quot;, &quot;w&quot;))
{
    int originalImageWidth = 0, originalImageHeight = 0;
    using (Tiff image = Tiff.Open(singleComparisonJobConfig.IntensityImageFilePathList[0], &quot;r&quot;))
    {
        originalImageWidth = image.GetField(TiffTag.IMAGEWIDTH)[0].ToInt();
        originalImageHeight = image.GetField(TiffTag.IMAGELENGTH)[0].ToInt();
    }

    bigTiff.SetField(
        TiffTag.IMAGEWIDTH,
        singleComparisonJobConfig.IntensityImageFilePathList.Count * originalImageWidth);
    bigTiff.SetField(TiffTag.IMAGELENGTH, originalImageHeight);
    bigTiff.SetField(TiffTag.PHOTOMETRIC, Photometric.MINISBLACK);

    bigTiff.SetField(TiffTag.BITSPERSAMPLE, 8);
    bigTiff.SetField(TiffTag.SAMPLESPERPIXEL, 1);

    // 这个参数很关键
    // The default is 2 * *32 - 1, which is effectively infinity. That is, the entire image is one strip. 
    // Use of a single strip is not recommended.Choose RowsPerStrip such that each strip is about 8K bytes, even if the data is not compressed, 
    // since it makes buffering simpler for readers.The 8K value is fairly arbitrary, but seems to work well.
    bigTiff.SetField(TiffTag.ROWSPERSTRIP, 1);
    bigTiff.SetField(TiffTag.COMPRESSION, Compression.NONE);
    bigTiff.SetField(TiffTag.PLANARCONFIG, PlanarConfig.CONTIG);

    // TILEWIDTH TILELENGTH要是16的倍数
    // bigTiff.SetField(TiffTag.TILEWIDTH, 5120);
    // bigTiff.SetField(TiffTag.TILELENGTH, 10240);
    // bigTiff.SetField(TiffTag.TILEDEPTH, 10240);

    // var a = bigTiff.TileSize();
    Tiff[] originalImages = new Tiff[singleComparisonJobConfig.IntensityImageFilePathList.Count];
    for (int i = 0; i &lt; singleComparisonJobConfig.IntensityImageFilePathList.Count; i++)
    {
        originalImages[i] = Tiff.Open(singleComparisonJobConfig.IntensityImageFilePathList[i], &quot;r&quot;);
    }

    byte[] newBuff =
        new byte[originalImageWidth * singleComparisonJobConfig.IntensityImageFilePathList.Count];
    byte[] buffer = new byte[originalImageWidth];
    for (int j = 0; j &lt; originalImageHeight; j++)
    {
        Console.WriteLine(j);
        Console.WriteLine(DateTime.Now);
        for (int i = 0; i &lt; singleComparisonJobConfig.IntensityImageFilePathList.Count; i++)
        {
            originalImages[i].ReadScanline(buffer, j);
            Buffer.BlockCopy(buffer, 0, newBuff, i * originalImageWidth, originalImageWidth * sizeof(byte));
        }

        bigTiff.WriteScanline(newBuff, j);
    }
    bigTiff.WriteDirectory();
    bigTiff.Close();
}
</code></pre>
<p>strip这个参数很关键，如果文件很大，比如超过4g，不设置strip的话会导致libtiff.net报错，所以一般是一个strip为8000个byte，这样设置读的比较快<br>
1）简单的文件，1个Strip足以。<br>
2）每个Strip大小是相同的。<br>
3）出于某种目的，文件可以分成若干Strip。<br>
4）Script需要对齐处理。<br>
5）文件有两种基本分块模式 Strip，Tile<br>
Strip 高度方向分块<br>
Tile  像打豆腐一样分块</p>
<p>分块就是若干字节（若干行）写一次；<br>
并且要记录每一块，写的位置。<br>
Some manufacturers make life difficult by writing large amounts of uncompressed data as a single strip. This is contrary to the recommendations of the spec. The following makes an attempt at breaking such images into strips closer to the recommended 8k bytes. A side effect, however, is that the RowsPerStrip tag value may be changed.</p>
<p>在wpf展示bigtiff（只读一些行，直接用bitmap加载会报错，所以有缩放功能时需要自己判断读入哪些行）</p>
<pre><code class="language-csharp">using (Tiff bigTiff = Tiff.Open(@&quot;D:\desktop\test\新建文件夹 (17)\5.tif&quot;, &quot;r&quot;))
{
    int originalImageWidth = bigTiff.GetField(TiffTag.IMAGEWIDTH)[0].ToInt();
    int originalImageHeight = bigTiff.GetField(TiffTag.IMAGELENGTH)[0].ToInt();

    double canvasHeight = grid.Height;
    int skip = Convert.ToInt32(originalImageHeight / canvasHeight);
    int resizedHeight = Convert.ToInt32(canvasHeight);
    int resizedWidth = Convert.ToInt32(originalImageWidth / skip);

    byte[,] bufferRect = new byte[resizedHeight, resizedWidth];
    byte[] buffer = new byte[originalImageWidth];
    for (int j = 0; j &lt; originalImageHeight; j += skip)
    {
        bigTiff.ReadScanline(buffer, j);
        for (int i = 0; i / skip &lt; resizedWidth; i += skip)
        {
            bufferRect[j / skip, i / skip] = buffer[i];
        }
    }

    byte[] bufferRectFlatten = new byte[resizedHeight * resizedWidth];
    Buffer.BlockCopy(bufferRect, 0, bufferRectFlatten, 0, resizedHeight * resizedWidth * sizeof(byte));
    BitmapSource bitmapSource = BitmapSource.Create(
        resizedWidth,
        resizedHeight,
        96.0,
        96.0,
        PixelFormats.Gray8,
        BitmapPalettes.Gray256,
        bufferRectFlatten,
        (resizedWidth * 8 + 7) / 8);

    image.Source = bitmapSource;
}
</code></pre>
]]></content>
    </entry>
</feed>